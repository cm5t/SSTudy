# ======================================================================
# SST Study Sphere ‚Äî A study notes sharing platform for SST students.
# Built with Streamlit (frontend) and Supabase (backend database + storage).
# A large majority of this code was generated by Antigravity (to save time, not that I can't code this project myself), using many AI models (due to Quota Limit). The main ones were Gemini 3 Pro and 3 Flash, with abit of Claude Opus 4.6.
# All prompting and alpha-testing was done by me (Dylan), and Supabase creation of columns, Streamlit secrets.toml are all mine. I did the pushing of this project to Github. All prompts was created by me. On some instances, I coded myself (Mainly for choosing of AI Model and instructions to give the AI) and guided the AI to solve some of the problems at times.
# Instructions to user was written by Shao Kai, presentation and video by Shao Kai and Drake.
# Some edge cases (Username limit) was suggested by Drake.
# The above comments was created by me (me suggesting the human, Dylan, not the AI). Some others were generated by Antigravity.
# Some templates (created by me on Google Slides) were used to generate the UI that I desire (that feels not 'blatantly AI').
# All Rights Reserved. (c) 2026 SST Study Sphere team.
# ======================================================================

import streamlit as st

# Initialize user session state before any other imports to avoid issues
if 'user' not in st.session_state:
    st.session_state.user = None

from supabase import create_client, Client
import mimetypes
import math
import hashlib
import time
import google.generativeai as genai
import io


# ----------------------------------------------------------------------
# Utility Functions
# General-purpose helpers used across the application.
# ----------------------------------------------------------------------
def format_size(size_bytes):
    """Convert a byte count into a human-readable string (e.g. '2.5 MB')."""
    if size_bytes == 0:
        return "0B"
    size_units = ("B", "KB", "MB", "GB", "TB")
    unit_index = int(math.floor(math.log(size_bytes, 1024)))
    unit_value = math.pow(1024, unit_index)
    rounded_size = round(size_bytes / unit_value, 2)
    return f"{rounded_size} {size_units[unit_index]}"

def calculate_level(xp):
    """Derive user level from their XP using a square-root curve."""
    return math.floor(math.sqrt(xp / 50))

def calculate_next_level_xp(level):
    """Calculate the total XP needed to reach the next level."""
    return 50 * ((level + 1) ** 2)

# ----------------------------------------------------------------------
# Page config
# ----------------------------------------------------------------------
st.set_page_config(page_title="SST Study Sphere", page_icon="üè´", layout="wide")

# ----------------------------------------------------------------------
# Persistent Session Storage
# Saves and loads user session data to auth_token.json for auto-login.
# ----------------------------------------------------------------------
import os
import json

SESSION_FILE = "auth_token.json"


# ----------------------------------------------------------------------
# Supabase Client Setup
# Creates and caches the Supabase client in session_state.
# ----------------------------------------------------------------------
def get_supabase():
    """Return Supabase client, cached in session_state across reruns."""
    if 'supabase_client' not in st.session_state:
        try:
            st.session_state.supabase_client = create_client(
                st.secrets["supabase"]["url"],
                st.secrets["supabase"]["key"]
            )
        except Exception as e:
            st.error(f"Failed to connect to Supabase: {e}")
            st.stop()
    return st.session_state.supabase_client

supabase = get_supabase()

# ----------------------------------------------------------------------
# Gemini AI Setup
# Configures the Google Generative AI SDK for content moderation (tagging)
# and the AI Study Buddy feature. The API key is read from secrets.toml.
# HAS_AI is True if configuration succeeded, False otherwise.
# ----------------------------------------------------------------------
def init_gemini():
    """Attempt to configure the Gemini AI SDK. Returns True on success."""
    try:
        api_key = None
        if "GOOGLE_API_KEY" in st.secrets:
            api_key = st.secrets["GOOGLE_API_KEY"]
        elif "supabase" in st.secrets and "GOOGLE_API_KEY" in st.secrets["supabase"]:
            api_key = st.secrets["supabase"]["GOOGLE_API_KEY"]

        if api_key:
            genai.configure(api_key=api_key, transport='rest')
            return True
        return False
    except Exception as e:
        print(f"init_gemini error: {e}")
        return False

HAS_AI = init_gemini()

def get_ai_tagging(description, file_bytes=None, mime_type=None):
    """Use Gemini AI to auto-detect Subject, Level, and content suitability.
    Returns (subject, level, is_suitable). Tries multiple model fallbacks.
    """
    if not HAS_AI:
        return "AI Not Configured", "AI Not Configured", True
    
    models_to_try = [
        'gemini-2.5-flash-lite', 
        'gemini-2.0-flash', 
        'gemini-2.0-flash-lite', 
        'gemini-2.5-flash'
    ]
    
    response_text = None
    last_error = ""
    for model_name in models_to_try:
        try:
            model = genai.GenerativeModel(model_name)
            
            prompt = """
            Analyze the following study note content and/or description for a study notes platform (SST Study Sphere).
            
            Tasks:
            1. Determine if the content is "Suitable" for a study notes sharing site. 
               - Suitable: Study notes, questions, guides, school projects, academic discussions.
               - Unsuitable: Memes, jokes, random images, spam, off-topic content.
            2. If suitable, determine the most appropriate 'Subject' and 'Level' from the lists.
               Subjects: ['English', 'Chinese', 'Malay', 'Tamil', 'Math', 'Physics', 'Chemistry', 'Biology', 'Computing', 'Biotechnology', 'Design Studies', 'Electronics', 'Geography', 'History', 'Social Studies', 'CCE', 'Changemakers']
               Levels: ['Sec 1', 'Sec 2', 'Sec 3', 'Sec 4']
            
            Rules:
            1. 'Changemakers' is ONLY for 'Sec 1' or 'Sec 2'.
            2. 'Computing', 'Biotechnology', 'Design Studies', 'Electronics' are ONLY for 'Sec 3' or 'Sec 4'.
            3. If the content is Unsuitable, still try to pick the closest Subject/Level if possible, but clearly mark it as Unsuitable.
            
            Return the result in this exact format:
            Suitability: [Suitable/Unsuitable]
            Subject: [Subject]
            Level: [Level]
            """
            
            content = [prompt]
            if description:
                content.append(f"Description: {description}")
            
            if file_bytes and mime_type:
                 if mime_type.startswith('image/') or mime_type == 'application/pdf':
                      content.append({"mime_type": mime_type, "data": file_bytes})

            response = model.generate_content(content)
            response_text = response.text
            break 
        except Exception as e:
            last_error = str(e)
            continue
            
    if not response_text:
        st.error(f"GenAI Error (All models tried): {last_error}")
        return None, None, True

    # Parse response_text
    suitability = "Suitable"
    subject = "Math"
    level = "Sec 1"
    
    for line in response_text.split('\n'):
        if "Suitability:" in line:
            suitability = line.split("Suitability:")[1].strip()
        elif "Subject:" in line:
            subject = line.split("Subject:")[1].strip()
        elif "Level:" in line:
            level = line.split("Level:")[1].strip()
            
    valid_subjects = ['English', 'Chinese', 'Malay', 'Tamil', 'Math', 'Physics', 'Chemistry', 'Biology', 'Computing', 'Biotechnology', 'Design Studies', 'Electronics', 'Geography', 'History', 'Social Studies', 'CCE', 'Changemakers']
    valid_levels = ['Sec 1', 'Sec 2', 'Sec 3', 'Sec 4']
    
    subject = subject.replace("*", "").replace("`", "")
    level = level.replace("*", "").replace("`", "")
    is_suitable = "unsuitable" not in suitability.lower()

    if subject not in valid_subjects: subject = "Math"
    if level not in valid_levels: level = "Sec 1"
    
    return subject, level, is_suitable


def ai_study_buddy(topic, subject):
    """Generate a study guide by fetching relevant notes from the database
    and feeding them to Gemini AI along with the user's topic and subject.
    Returns the AI-generated study guide as a markdown string.
    """
    if not HAS_AI:
        return "AI is not configured. Please add GOOGLE_API_KEY to secrets."
        
    # 1. Pre-calculate content items (do this once)
    try:
        notes = supabase.table("projects").select("*").eq("subject", subject).ilike("title", f"%{topic}%").limit(3).execute().data
        if not notes:
             notes = supabase.table("projects").select("*").eq("subject", subject).limit(2).execute().data
            
        language_prompts = {
            'Chinese': "Please respond entirely in Chinese (ÁÆÄ‰Ωì‰∏≠Êñá).",
            'Malay': "Please respond entirely in Malay (Bahasa Melayu).",
            'Tamil': "Please respond entirely in Tamil (‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç).",
        }
        lang_instruction = language_prompts.get(subject, "Please respond in English.")

        content_items = []
        prompt_intro = f"""
        You are an AI Study Buddy for Singapore Secondary School students (SST).
        User wants to study: '{topic}' in Subject: '{subject}'.
        
        CONTEXT: 
        1. Frame all academic explanations within the context of the GCSE O-Level examination standards.
        2. {lang_instruction}
        
        RULES:
        1. STRICT SOURCE USAGE: Analyze the provided note contents (descriptions and actual files).
        2. Only pick information from the provided sources. Do NOT create your own sources or hallucinate non-existent files. If said topic is not found in the sources, just recommend other platforms - Google Classroom or Holy Grail.
        3. If the provided notes are insufficient, you may provide general academic research for '{topic}' but CLEARLY LABEL it as "General Research" and distinguish it from the user's notes.
        4. Summarize key points, provide a comprehensive study guide, and highlight specific details from the user's notes.
        5. Format with clear headings, bullet points, and a friendly tone.
        6. IF THERE IS NO SOURCES ON THAT PARTICULAR SUBJECT, JUST SAY 'There are no sources in [SUBJECT]. Please add your notes to that subject, and other notes to other subjects so others do not face the same difficulty!'
        7. If said topic is off-topic, also provide a warning like 'This source seems to be off-topic. Please only ask for study-related content. If you think this is a bug, please rephrase or simplify the sentence.'
        """
        content_items.append(prompt_intro)

        for note in notes:
            text_context = f"Note Title: {note['title']}\nDescription: {note['description']}\n"
            content_items.append(text_context)
            
            if note.get('file') and note['file'] != "#":
                try:
                    url = note['file']
                    if "/public/file/" in url:
                        storage_path = url.split("/public/file/")[1]
                        file_data = supabase.storage.from_("file").download(storage_path)
                        m_type, _ = mimetypes.guess_type(note.get('file_name', ''))
                        if m_type and (m_type.startswith('image/') or m_type == 'application/pdf'):
                            content_items.append({"mime_type": m_type, "data": file_data})
                except Exception as file_err:
                    print(f"Error downloading file for AI: {file_err}")
    except Exception as e:
        return f"Error gathering context: {e}"

    # 2. Try models in order
    models_to_try = [
        'gemini-2.5-flash-lite', 
        'gemini-2.0-flash', 
        'gemini-2.0-flash-lite', 
        'gemini-2.5-flash'
    ]
    last_err = ""
    for model_name in models_to_try:
        try:
            model = genai.GenerativeModel(model_name)
            response = model.generate_content(content_items)
            return response.text
        except Exception as e:
            last_err = str(e)
            continue
            
    return f"Error generating study guide (Tried all models): {last_err}"


# ----------------------------------------------------------------------
# Storage Bucket Setup
# Ensures the Supabase Storage bucket for uploaded files exists.
# Cached so it only runs once per app session.
# ----------------------------------------------------------------------
@st.cache_resource
def get_or_create_bucket():
    """Return the name of the file storage bucket, creating it if needed."""
    bucket_name = "file"
    try:
        buckets = supabase.storage.list_buckets()
        bucket_names = [b.name for b in buckets]
        if bucket_name not in bucket_names:
            supabase.storage.create_bucket(bucket_name, options={"public": True})
        return bucket_name
    except:
        return bucket_name

BUCKET_NAME = get_or_create_bucket()

# ----------------------------------------------------------------------
# Cached Data Fetchers
# These functions query Supabase and cache results using Streamlit's
# @st.cache_data to avoid redundant database calls on every rerun.
# Call .clear() on any of these to invalidate the cache after mutations.
# ----------------------------------------------------------------------
@st.cache_data(ttl=60)
def fetch_projects(query, subject, level, sort_by):
    """Fetch notes from the 'projects' table with optional filters and sorting."""
    db_query = supabase.table("projects").select("*")
    if sort_by == "Most Votes":
        db_query = db_query.order("votes", desc=True)
    else:  # Default: most recent first
        db_query = db_query.order("created_at", desc=True)

    if subject != 'All':
        db_query = db_query.eq("subject", subject)
    if level != 'All':
        db_query = db_query.cs("level", [level])
    if query:
        db_query = db_query.ilike("title", f"%{query}%")
    return db_query.execute().data

@st.cache_data(ttl=300)
def fetch_leaderboard():
    """Fetch the top 50 users by XP for the leaderboard."""
    response = supabase.table("users").select("username, xp").order("xp", desc=True).limit(50).execute()
    return response.data

@st.cache_data(ttl=60)
def fetch_user_votes(username):
    """Fetch all votes the given user has cast.
    Returns a dict mapping project_id ‚Üí {vote: int, xp_awarded: bool}.
    """
    response = supabase.table("project_likes").select("project_id, vote, xp_awarded").eq("username", username).execute()
    return {r['project_id']: {'vote': r.get('vote', 1), 'xp_awarded': r.get('xp_awarded', False)} for r in response.data}

# ----------------------------------------------------------------------
# DataManager
# Central class that encapsulates all database operations:
#   - User authentication (signup, login)
#   - Note publishing (add_note) with file upload and XP rewards
#   - Voting system (vote_note) with XP grant/deduct logic
#   - Data retrieval wrappers (get_projects, get_leaderboard, get_user_votes)
# ----------------------------------------------------------------------
class DataManager:
    def __init__(self):
        self.bucket_name = BUCKET_NAME
        if 'user_votes' not in st.session_state:
            if 'user' in st.session_state and st.session_state.user:
                st.session_state.user_votes = self.get_user_votes()
            else:
                st.session_state.user_votes = {}
        self.user_votes = st.session_state.user_votes

    def hash_password(self, password):
        """Hash a password with SHA-256 for storage and comparison."""
        return hashlib.sha256(password.encode()).hexdigest()

    def signup(self, email, username, password):
        """Register a new user. Returns (True, user_dict) or (False, error_msg)."""
        try:
            if not (3 <= len(username) <= 36):
                return False, "Username must be between 3 and 36 characters."

            existing_user = supabase.table("users").select("*").eq("username", username).execute()
            if existing_user.data:
                return False, "Username already taken."

            existing_email = supabase.table("users").select("*").eq("email", email).execute()
            if existing_email.data:
                return False, "Email already registered."

            hashed_pw = self.hash_password(password)
            user_data = {
                "email": email,
                "username": username,
                "password": hashed_pw,
                "xp": 0
            }
            response = supabase.table("users").insert(user_data).execute()
            if response.data:
                return True, response.data[0]
            return False, "Signup failed."
        except Exception as e:
            return False, str(e)

    def login(self, email, password):
        """Authenticate user by email + hashed password. Returns (True, user_dict) or (False, error_msg)."""
        try:
            hashed_pw = self.hash_password(password)
            response = supabase.table("users").select("*").eq("email", email).eq("password", hashed_pw).execute()
            if response.data:
                return True, response.data[0]
            return False, "Invalid email or password."
        except Exception as e:
            return False, str(e)



    def refresh_user(self):
        """Re-fetch the current user's data from the database to get updated XP, etc."""
        if 'user' in st.session_state and st.session_state.user:
            try:
                username = st.session_state.user['username']
                response = supabase.table("users").select("*").eq("username", username).execute()
                if response.data:
                    st.session_state.user = response.data[0]
            except Exception as e:
                print(f"Error refreshing user: {e}")

    def get_user_votes(self):
        if 'user' not in st.session_state or not st.session_state.user:
            return {}
        try:
            return fetch_user_votes(st.session_state.user['username'])
        except Exception as e:
            print(f"Error fetching user votes: {e}")
            return {}

    def add_note(self, title, subject, level, description, uploaded_file):
        """Publish a new note. Uploads the file to Supabase Storage,
        inserts the note into the 'projects' table, and awards +15 XP.
        """
        if 'user' not in st.session_state or not st.session_state.user:
            return False

        current_username = st.session_state.user['username']
        file_url = "#"
        file_name = None
        file_size = 0

        if uploaded_file:
            file_name = uploaded_file.name
            file_size = uploaded_file.size
            safe_filename = file_name.replace(" ", "_").replace("(", "").replace(")", "")
            file_path = f"{current_username}/{safe_filename}"

            try:
                file_bytes = uploaded_file.getvalue()
                content_type = uploaded_file.type or mimetypes.guess_type(file_name)[0]
                supabase.storage.from_(self.bucket_name).upload(
                    path=file_path,
                    file=file_bytes,
                    file_options={"content-type": content_type, "upsert": "true"}
                )
                file_url = supabase.storage.from_(self.bucket_name).get_public_url(file_path)
            except Exception as e:
                st.error(f"File upload failed: {e}")
                return False

        new_note = {
            "title": title,
            "subject": subject,
            "level": [level],
            "author": current_username,
            "description": description,
            "file": file_url,
            "file_name": file_name,
            "file_size": file_size,
            "votes": 0
        }

        try:
            supabase.table("projects").insert(new_note).execute()
            author_data = supabase.table("users").select("xp").eq("username", current_username).execute()
            if author_data.data:
                current_xp = author_data.data[0]['xp']
                new_xp = current_xp + 15
                supabase.table("users").update({"xp": new_xp}).eq("username", current_username).execute()

            fetch_projects.clear()
            fetch_leaderboard.clear()
            self.refresh_user()
            return True
        except Exception as e:
            st.error(f"Database insert failed: {e}")
            return False

    def vote_note(self, note_id, current_score, note_author, vote_value):
        """Vote on a note. vote_value: +1 (upvote) or -1 (downvote).
        XP rules: Upvote grants +10 XP. Downvote-after-upvote deducts 10 XP.
        First downvote (no prior vote) does not affect XP.
        """
        if 'user' not in st.session_state or not st.session_state.user:
            st.warning("You must be logged in to vote.")
            return False

        current_username = st.session_state.user['username']
        existing = st.session_state.user_votes.get(note_id)

        try:
            if existing is None:
                # First vote on this post
                xp_awarded = False
                if vote_value == 1:
                    # Award XP to author on first upvote
                    author_data = supabase.table("users").select("xp").eq("username", note_author).execute()
                    if author_data.data:
                        new_xp = author_data.data[0]['xp'] + 10
                        supabase.table("users").update({"xp": new_xp}).eq("username", note_author).execute()
                    xp_awarded = True
                
                supabase.table("project_likes").insert({
                    "project_id": note_id,
                    "username": current_username,
                    "vote": vote_value,
                    "xp_awarded": xp_awarded
                }).execute()
                supabase.table("projects").update({"votes": current_score + vote_value}).eq("id", note_id).execute()
                st.session_state.user_votes[note_id] = {'vote': vote_value, 'xp_awarded': xp_awarded}

            elif existing['vote'] == vote_value:
                # Same vote again ‚Äì no-op
                return False
            else:
                # Toggle: changing vote direction (swing = 2 * vote_value)
                already_awarded = existing.get('xp_awarded', False)
                
                if vote_value == 1:
                    # Switching TO upvote ‚Üí always grant +10 XP
                    author_data = supabase.table("users").select("xp").eq("username", note_author).execute()
                    if author_data.data:
                        new_xp = author_data.data[0]['xp'] + 10
                        supabase.table("users").update({"xp": new_xp}).eq("username", note_author).execute()
                    new_xp_awarded = True
                elif vote_value == -1 and already_awarded:
                    # Switching TO downvote after upvote ‚Üí deduct the 10 XP
                    author_data = supabase.table("users").select("xp").eq("username", note_author).execute()
                    if author_data.data:
                        new_xp = max(0, author_data.data[0]['xp'] - 10)
                        supabase.table("users").update({"xp": new_xp}).eq("username", note_author).execute()
                    new_xp_awarded = False
                else:
                    new_xp_awarded = already_awarded

                supabase.table("project_likes").update({
                    "vote": vote_value,
                    "xp_awarded": new_xp_awarded
                }).eq("project_id", note_id).eq("username", current_username).execute()
                supabase.table("projects").update({"votes": current_score + (2 * vote_value)}).eq("id", note_id).execute()
                st.session_state.user_votes[note_id] = {'vote': vote_value, 'xp_awarded': new_xp_awarded}

            fetch_projects.clear()
            fetch_leaderboard.clear()
            fetch_user_votes.clear()
            if current_username == note_author:
                self.refresh_user()
            return True
        except Exception as e:
            st.error(f"Vote failed: {e}")
            return False

    def get_projects(self, query="", subject='All', level='All', sort_by="Recent"):
        try:
            return fetch_projects(query, subject, level, sort_by)
        except Exception as e:
            st.error(f"Error fetching projects: {e}")
            return []

    def get_leaderboard(self):
        try:
            return fetch_leaderboard()
        except Exception as e:
            st.error(f"Error fetching leaderboard: {e}")
            return []

data = DataManager()

# ----------------------------------------------------------------------
# CSS Styling
# Defines the visual appearance for note cards, buttons, leaderboard
# rows, form inputs, and tab labels. Injected via st.markdown.
# ----------------------------------------------------------------------
st.markdown("""
    <style>
    .main-header { font-size: 3.15rem; color: #4C51BF; font-weight: bold}
    
    .note-card {
        background-color: #898989 !important;
        border: 1px solid #e2e8f0 !important;
        border-radius: 8px !important;
        padding: 24px !important;
        color: #000000 !important;
        display: flex;
        height: 300px;
        flex-direction: column;
        justify-content: flex-start;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
    }

    .note-card h4 {
        color: #000000 !important;
        font-size: 1.5rem !important;
    }

    .note-author { 
        color: #1f2937 !important; 
        font-weight: 700; 
        font-size: 0.9rem;
        margin-bottom: 12px;
    }

    .note-tag {
        background-color: #d1d5db !important;
        color: #000000 !important;
        padding: 6px 12px;
        border-radius: 8px;
        font-size: 0.85rem;
        font-weight: 600;
        display: block;
        width: 100%;
        margin-bottom: 18px;
    }

    .note-description {
        color: #000000 !important;
        font-size: 1rem;
        line-height: 1.5 !important;
        max-height: 4.5em !important;
        display: -webkit-box !important;
        -webkit-line-clamp: 3 !important;
        -webkit-box-orient: vertical !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
        margin-bottom: 8px;
        word-break: break-all;
        overflow-wrap: break-word;
    }

    div[data-testid="stButton"] button, div[data-testid="stLinkButton"] a {
        background-color: #e5e7eb !important;
        color: #000000 !important;
        border: 1px solid #d1d5db !important;
        border-radius: 8px !important;
        width: 100% !important;
        padding: 6px !important;
        font-weight: 600 !important;
        margin-bottom: 0px !important;
    }
    
    div[data-testid="stButton"] button:hover {
        background-color: #d1d5db !important;
    }

    button[data-testid="stTab"] p { font-size: 1.5rem !important; }
    div[data-testid="stExpander"] p { font-size: 1.5rem !important; }
    label[data-testid="stWidgetLabel"] p { font-size: 1.5rem !important; }
    
    div[data-testid="stForm"] input, div[data-testid="stForm"] textarea, div[data-testid="stForm"] div[role="combobox"] {
        font-size: 1.2rem !important;
    }

    .leaderboard-row {
        font-size: 1.5rem !important;
    }
    .leaderboard-rank {
        font-size: 1.8rem !important;
    }
    </style>
""", unsafe_allow_html=True)

# ----------------------------------------------------------------------
# Session Persistence & Auto-Login
# Saves/restores the logged-in user to auth_token.json so users
# stay logged in across browser reloads and app restarts.
# ----------------------------------------------------------------------


def save_session():
    """Save user session data to disk for auto-login on next visit."""
    try:
        session_data = {}
        if 'user' in st.session_state and st.session_state.user:
            session_data["custom_user"] = st.session_state.user
        with open(SESSION_FILE, "w") as f:
            json.dump(session_data, f)
    except Exception as e:
        print(f"Error saving session: {e}")

def restore_session():
    """Restore user session from disk if available."""
    if st.session_state.user is not None:
        return # User is already logged in, no need to restore
    try:
        if os.path.exists(SESSION_FILE):
            with open(SESSION_FILE, "r") as f:
                session_data = json.load(f)
            if "custom_user" in session_data:
                st.session_state.user = session_data["custom_user"]
                st.session_state.user_votes = data.get_user_votes()
                print(f"Session restored for {st.session_state.user['username']}")
    except Exception as e:
        print(f"Session restoration error: {e}")

# Attempt to restore session on app startup
restore_session()


# ----------------------------------------------------------------------
# LOGIN PAGE (shown when user is not authenticated)
# Provides Email/Password sign-in and sign-up forms.
# ----------------------------------------------------------------------
if st.session_state.user is None:
    st.markdown('<div class="main-header" style="text-align: center;">üè´ SST Study Sphere</div>', unsafe_allow_html=True)
    st.markdown("<h3 style='text-align: center;'>Please Sign In to Continue</h3>", unsafe_allow_html=True)

    tab_login, tab_signup = st.tabs(["Sign In", "Sign Up"])

    with tab_login:
        with st.form("login_form"):
            email = st.text_input("Email")
            password = st.text_input("Password", type="password")
            submitted = st.form_submit_button("Sign In")
            if submitted:
                if not email or not password:
                    st.error("Please fill in all fields.")
                else:
                    success, res = data.login(email, password)
                    if success:
                        st.session_state.user = res
                        st.session_state.user_votes = data.get_user_votes()
                        save_session() # Save for auto-login
                        st.success(f"Welcome back, {res['username']}!")
                        time.sleep(1)
                        st.rerun()
                    else:
                        st.error(res)

    with tab_signup:
        with st.form("signup_form"):
            new_email = st.text_input("Email")
            new_user = st.text_input("Username")
            new_pass = st.text_input("Password", type="password")
            confirm_pass = st.text_input("Confirm Password", type="password")
            submitted = st.form_submit_button("Sign Up")
            if submitted:
                if not new_user or not new_pass or not new_email:
                    st.error("Please fill in all fields.")
                elif new_pass != confirm_pass:
                    st.error("Passwords do not match.")
                else:
                    success, res = data.signup(new_email, new_user, new_pass)
                    if success:
                        st.session_state.user = res
                        st.session_state.user_votes = {}
                        save_session() # Save for auto-login
                        st.success("Account created successfully! Logging in...")
                        time.sleep(1)
                        st.rerun()
                    else:
                        st.error(res)

else:
    # ==================================================================
    # MAIN APP (shown after successful login)
    # Contains three tabs: Notes Forum, Leaderboard, and AI Tutor.
    # ==================================================================
    data.refresh_user()  # Sync latest user data (XP, level) from DB

    # ---------- Top Bar: Branding, user info, logout ----------
    with st.container():
        col_brand, col_user_info, col_logout = st.columns([3, 1, 0.5])
        col_brand.markdown('<div class="main-header">üè´ SST Study Sphere</div>', unsafe_allow_html=True)

        xp = st.session_state.user['xp']
        level = calculate_level(xp)
        next_level_xp = calculate_next_level_xp(level)

        col_user_info.markdown(f"<div style='font-size: 120%;'>Welcome, {st.session_state.user['username']} | <b>Level {level}</b> ({xp}/{next_level_xp} XP)</div>", unsafe_allow_html=True)
        if col_logout.button("Logout"):
            st.session_state.user = None
            st.session_state.user_votes = {}
            # Clear persistent session file on logout
            if os.path.exists(SESSION_FILE):
                os.remove(SESSION_FILE)
            st.rerun()


    tab1, tab2, tab3 = st.tabs(["üìö Notes Forum", "üèÜ Leaderboard", "ü§ñ AI Tutor"])

    # ==========================================================
    # TAB 1: Notes Forum
    # Two modes: Focus View (single post) or Grid View (browse all)
    # ==========================================================
    with tab1:
        # Initialize the focused note tracker (None = grid view)
        if 'focused_note_id' not in st.session_state:
            st.session_state.focused_note_id = None

        if st.session_state.focused_note_id is not None:
            # ---------- Focus View: Full post detail ----------
            # Find the focused note
            focused_id = st.session_state.focused_note_id
            # Fetch fresh data for this note
            try:
                note_data = supabase.table("projects").select("*").eq("id", focused_id).execute().data
            except:
                note_data = []

            if note_data:
                note = note_data[0]
                score = note.get('votes', 0)
                user_vote_info = st.session_state.user_votes.get(note['id'])
                current_vote = user_vote_info['vote'] if user_vote_info else 0

                if st.button("‚Üê Back to Notes"):
                    st.session_state.focused_note_id = None
                    st.rerun()

                st.markdown(f"## {note['title']}")
                st.markdown(f"*By **{note['author']}*** ‚Äî {note['subject']} ‚Ä¢ {', '.join(note['level']) if note['level'] else ''}")

                # Vote score
                if score > 0:
                    score_color = "#22c55e"
                    score_text = f"+{score}"
                elif score < 0:
                    score_color = "#ef4444"
                    score_text = str(score)
                else:
                    score_color = "#888"
                    score_text = "0"
                st.markdown(f"**Votes:** <span style='color: {score_color}; font-weight: bold; font-size: 1.2rem;'>{score_text}</span>", unsafe_allow_html=True)

                st.markdown("---")
                st.markdown(note['description'] or "No description provided.")
                st.markdown("---")

                if note['file'] and note['file'] != "#":
                    f_name = note.get('file_name') or "File"
                    download_url = f"{note['file']}?download="
                    st.link_button(f"‚¨áÔ∏è Download {f_name}", download_url, use_container_width=False)

                # Vote buttons
                v_col1, v_col2, v_col3 = st.columns([1, 1, 3])
                up_label = "‚úÖ Upvoted" if current_vote == 1 else "‚ñ≤ Upvote"
                down_label = "‚ùå Downvoted" if current_vote == -1 else "‚ñº Downvote"

                if v_col1.button(up_label, key=f"up_{note['id']}", disabled=(current_vote == 1), use_container_width=True):
                    if data.vote_note(note['id'], score, note['author'], 1):
                        st.rerun()

                if v_col2.button(down_label, key=f"dn_{note['id']}", disabled=(current_vote == -1), use_container_width=True):
                    if data.vote_note(note['id'], score, note['author'], -1):
                        st.rerun()
            else:
                st.warning("Note not found.")
                if st.button("‚Üê Back to Notes"):
                    st.session_state.focused_note_id = None
                    st.rerun()

        else:
            # ---------- Grid View: Browse & upload notes ----------

            # ¬∑¬∑¬∑¬∑¬∑ Upload Form ¬∑¬∑¬∑¬∑¬∑
            with st.expander("‚¨ÜÔ∏è Upload New Note", expanded=True):
                # initialize session state for form clearing if not exists
                if "upload_key" not in st.session_state:
                    st.session_state.upload_key = 0
                
                # We use a key-based approach to clear the form manually
                def clear_form():
                    st.session_state.upload_key += 1
                    st.session_state.ai_subject = "English"
                    st.session_state.ai_level = "Sec 1"

                if 'ai_subject' not in st.session_state: st.session_state.ai_subject = "English"
                if 'ai_level' not in st.session_state: st.session_state.ai_level = "Sec 1"
                
                with st.form(key=f"upload_form_{st.session_state.upload_key}", clear_on_submit=False):
                    note_title = st.text_input("Title")
                    u_file = st.file_uploader("Upload PDF/Video", type=['pdf', 'mp4', 'png', 'jpg'])
                    
                    subjects = ['English', 'Chinese', 'Malay', 'Tamil', 'Math', 'Physics', 'Chemistry', 'Biology', 'Computing', 'Biotechnology', 'Design Studies', 'Electronics', 'Geography', 'History', 'Social Studies', 'CCE', 'Changemakers']
                    levels = ['Sec 1', 'Sec 2', 'Sec 3', 'Sec 4']

                    # Pre-select the AI-suggested subject/level if available
                    subject_index = subjects.index(st.session_state.ai_subject) if st.session_state.ai_subject in subjects else 0
                    level_index = levels.index(st.session_state.ai_level) if st.session_state.ai_level in levels else 0

                    col_subject, col_level = st.columns(2)
                    note_subject = col_subject.selectbox("Subject", subjects, index=subject_index)
                    note_level = col_level.selectbox("Level", levels, index=level_index)

                    note_description = st.text_area("Description")
                    
                    # Button: ask AI to detect Subject & Level from content
                    if st.form_submit_button("Analyze & Suggest Tags"):
                        if not note_description and not u_file:
                            st.warning("Please upload a file or enter a description first.")
                        else:
                            with st.spinner("AI is analyzing content..."):
                                file_bytes = u_file.getvalue() if u_file else None
                                file_mime = u_file.type if u_file else None
                                suggested_subject, suggested_level, is_suitable = get_ai_tagging(note_description, file_bytes, file_mime)

                            if not is_suitable:
                                st.session_state.ai_result = {"suitability": False, "subject": None, "level": None}
                            else:
                                st.session_state.ai_result = {"suitability": True, "subject": suggested_subject, "level": suggested_level}
                    
                    # Show results OUTSIDE the Analyze button logic but INSIDE the form
                    if 'ai_result' in st.session_state:
                        res = st.session_state.ai_result
                        if not res["suitability"]:
                            st.warning("‚ö†Ô∏è Warning: AI detected that this post may not be suitable for this site (e.g. off-topic or inappropriate). Please ensure you are posting study-related content.")
                        elif res["subject"] and res["level"]:
                            st.info(f"AI Suggestion: Subject: **{res['subject']}**, Level: **{res['level']}**")
                            if st.form_submit_button("‚úÖ Apply Suggested Tags"):
                                st.session_state.ai_subject = res["subject"]
                                st.session_state.ai_level = res["level"]
                                st.success("Suggestion applied! Click 'Post Note' to finish.")
                                time.sleep(1)
                                st.rerun()

                    # Button: publish the note to the forum
                    if st.form_submit_button("Post Note (+15 XP)"):
                        if note_title and note_description:
                            with st.spinner("Publishing..."):
                                success = data.add_note(note_title, note_subject, note_level, note_description, u_file)
                            if success:
                                st.success("Note Published! You gained 15 XP.")
                                time.sleep(1)
                                clear_form()  # Reset form fields for next upload
                                st.rerun()
                        else:
                            st.warning("Please enter a title and description.")

            # ¬∑¬∑¬∑¬∑¬∑ Search & Filter Controls ¬∑¬∑¬∑¬∑¬∑
            col_search, col_subject_filter, col_level_filter, col_sort = st.columns([3, 1, 1, 1])
            search_query = col_search.text_input("Search", placeholder="Search notes...")
            subject_filter = col_subject_filter.selectbox("Subject Filter", ['All', 'English', 'Chinese', 'Malay', 'Tamil', 'Math', 'Physics', 'Chemistry', 'Biology', 'Computing', 'Biotechnology', 'Design Studies', 'Electronics', 'Geography', 'History', 'Social Studies', 'CCE', 'Changemakers'])
            level_filter = col_level_filter.selectbox("Level Filter", ['All', 'Sec 1', 'Sec 2', 'Sec 3', 'Sec 4'])
            sort_option = col_sort.selectbox("Sort By", ["Recent", "Most Votes"])

            # ¬∑¬∑¬∑¬∑¬∑ Note Cards Grid (3 columns) ¬∑¬∑¬∑¬∑¬∑
            notes = data.get_projects(search_query, subject_filter, level_filter, sort_option)

            if not notes:
                st.info("No notes found.")
            else:
                for i in range(0, len(notes), 3):
                    row_notes = notes[i:i+3]
                    cols = st.columns(3)
                    for j in range(3):
                        with cols[j]:
                            if j < len(row_notes):
                                note = row_notes[j]
                                score = note.get('votes', 0)

                                # Color the vote score: green (+), red (-), gray (0)
                                if score > 0:
                                    score_display = f"<span style='color: #22c55e; font-weight: bold;'>+{score}</span>"
                                elif score < 0:
                                    score_display = f"<span style='color: #ef4444; font-weight: bold;'>{score}</span>"
                                else:
                                    score_display = f"<span style='font-weight: bold;'>0</span>"

                                # Auto-detect file type tag from the uploaded file extension
                                uploaded_name = note.get('file_name') or ""
                                if uploaded_name:
                                    file_ext = uploaded_name.rsplit('.', 1)[-1].lower() if '.' in uploaded_name else ""
                                    if file_ext == 'pdf':
                                        file_tag = "üìÑ PDF"
                                    elif file_ext in ('mp4', 'mov', 'avi'):
                                        file_tag = "üé¨ Video"
                                    elif file_ext in ('mp3', 'wav', 'ogg', 'm4a'):
                                        file_tag = "üéôÔ∏è Voice"
                                    elif file_ext in ('png', 'jpg', 'jpeg', 'gif'):
                                        file_tag = "üñºÔ∏è Image"
                                    else:
                                        file_tag = f"üìé {file_ext.upper()}"
                                else:
                                    file_tag = "üì≠ No File"

                                st.markdown(f"""
                                    <div class="note-card">
                                        <h4>{note['title']}</h4>
                                        <div class="note-author">By {note['author']}</div>
                                        <div class="note-tag">{note['subject']} ‚Ä¢ {", ".join(note["level"]) if note["level"] else ""} ‚Ä¢ {file_tag}</div>
                                        <div class="note-description">{note['description'] or "No description provided."}</div>
                                        <div style="margin-top: 4px; font-size: 0.9rem;">Votes: {score_display}</div>
                                    </div>
                                """, unsafe_allow_html=True)

                                if st.button("üìñ View Full Post", key=f"view_{note['id']}", use_container_width=True):
                                    st.session_state.focused_note_id = note['id']
                                    st.rerun()
                            else:
                                st.empty()

    # ==========================================================
    # TAB 2: Leaderboard
    # Ranks users by XP, showing their level and total XP.
    # ==========================================================
    with tab2:
        st.header("Leaderboard üèÜ")
        leaderboard = data.get_leaderboard()

        for idx, user_row in enumerate(leaderboard):
            rank = idx + 1
            icon = "ü•á" if rank == 1 else "ü•à" if rank == 2 else "ü•â" if rank == 3 else f"#{rank}"

            with st.container(border=True):
                col_rank, col_name, col_lvl, col_xp = st.columns([1, 4, 1.5, 1.5])
                col_rank.markdown(f'<div class="leaderboard-rank">{icon}</div>', unsafe_allow_html=True)
                col_name.markdown(f'<div class="leaderboard-row"><b>{user_row["username"]}</b></div>', unsafe_allow_html=True)

                user_xp = user_row["xp"]
                user_level = calculate_level(user_xp)

                col_lvl.markdown(f'<div class="leaderboard-row">Lvl {user_level}</div>', unsafe_allow_html=True)
                col_xp.markdown(f'<div class="leaderboard-row">{user_xp} XP</div>', unsafe_allow_html=True)

    # ==========================================================
    # TAB 3: AI Study Buddy
    # Users pick a subject and type a topic. The AI fetches
    # relevant notes from the forum and generates a study guide.
    # ==========================================================
    with tab3:
        st.header("AI Study Buddy ü§ñ")
        st.markdown("Type in a subject and topic, and I'll compile materials from the notes for you!")

        col_ai_subject, col_ai_topic = st.columns([1, 2])
        ai_subject = col_ai_subject.selectbox("Choose Subject", ['English', 'Chinese', 'Malay', 'Tamil', 'Math', 'Physics', 'Chemistry', 'Biology', 'Computing', 'Biotechnology', 'Design Studies', 'Electronics', 'Geography', 'History', 'Social Studies', 'CCE', 'Changemakers'], key="sb_sub")
        ai_topic = col_ai_topic.text_input("What do you want to study? (e.g. 'Kinematics')", key="sb_top")

        if st.button("Compile Study Guide"):
            if not ai_topic:
                st.warning("Please enter a topic.")
            else:
                with st.spinner(f"Reading notes and compiling guide for {ai_topic}..."):
                    study_guide = ai_study_buddy(ai_topic, ai_subject)
                    st.markdown("---")
                    st.markdown(study_guide)
                    st.success("Compilation complete!")